{"version":3,"file":"index.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,WAAY,GAAIH,GACG,iBAAZC,QACdA,QAAkB,SAAID,IAEtBD,EAAe,SAAIC,GACpB,CATD,CASGK,MAAQC,QAAUC,QAAQ,I,uBCNzBC,EAAsB,CAAC,E,q2BCF3B,kBACI,WAAaC,GAAb,MACI,YAAMA,IAAQ,K,OACd,EAAKC,KAAO,c,CAChB,CACJ,OAL0B,OAK1B,EALA,CAA0BC,OAuBpBC,EAAc,CAChB,SACA,SACA,UACA,SACA,WACA,YACA,MACA,UAmBJ,SAAgBC,EAAeC,EAAYC,EAAuBC,GAC9D,MAAe,QAAXD,UAGUD,IAAMC,CACxB,CAEA,SAAgBE,EAA8BH,EAAYC,EAAaG,GACnE,OAAOC,MAAMC,QAAQN,KACbA,EAAEO,SAAWN,EAAOM,SAAWH,EAAOI,SACvCP,EAAOQ,OAAM,SAACC,EAAGC,GAAM,OAAAC,EAAQZ,EAAEW,GAAID,EAAG,KAAM,EAAF,KACxCN,GAAM,CACTS,sBAAsB,IAFA,GAIlC,CAEA,SAAgBC,EACZd,EACAC,EACAc,EACAX,G,MAEA,QAHA,IAAAW,IAAAA,EAAA,IAGiB,iBAANf,GAAwB,OAANA,EACzB,OAAO,EAIX,IAAIgB,EAAQ,KAAiChB,GAC7C,IAAK,IAAMiB,KAAOF,EACF,QAAZ,EAAAC,EAASC,UAAG,QAAZD,EAASC,GAASF,EAASE,IAG/B,GAAIb,EAAOI,QACHU,OAAOC,KAAKH,GAAUT,SAAWW,OAAOC,KAAKlB,GAAQM,OACrD,OAAO,EAIf,IAAK,IAAMU,KAAOhB,EACd,IAAKW,EAAQI,EAASC,GAAMhB,EAAOgB,GAAM,KAAM,EAAF,KACtCb,GAAM,CACTS,sBAAsB,KAEtB,OAAO,EAIf,OAAO,CACX,CAGA,SAAgBO,EAAgBnB,GAC5B,GAAsB,iBAAXA,GACP,GAAIH,EAAYuB,QAAQpB,GAAU,EAC9B,MAAM,IAAIqB,EAAY,uBAGvB,GAAIjB,MAAMC,QAAQL,GACrBA,EAAOsB,QAAQH,OAEZ,IAAsB,iBAAXnB,EAKd,MAAM,IAAIqB,EAAY,kBAJtBJ,OAAOC,KAAKlB,GACPsB,SAAQ,SAAAC,GAAK,OAAAJ,EAAenB,EAAOuB,GAAtB,G,CAK1B,CAEA,SAAgBZ,EACZZ,EACAC,EACAc,EAGAX,GASA,YAZA,IAAAW,IAAAA,EAAA,WAGA,IAAAX,IAAAA,EAAA,CACIS,sBAAsB,EACtBL,QAAQ,IAGRJ,EAAOS,sBACPO,EAAenB,GAGG,iBAAXA,EACAF,EAAcC,EAAGC,GAExBI,MAAMC,QAAQL,GACPE,EAAWH,EAAGC,EAAQG,GAEX,iBAAXH,GACAa,EAAYd,EAAGC,EAAQc,EAAUX,EAIhD,CA/FA,kBAOA,eASA,gBAmCA,mBAkBA,YA6Ba,EAAAqB,QAAU,QAEvB,IAAMC,EAAW,CACbd,QAAO,EACPa,QAAO,WAGX,UAAeC,C,GDxJK,KAAK,EAAGhC,G","sources":["webpack://schemion/webpack/universalModuleDefinition","webpack://schemion/webpack/startup","webpack://schemion/./src/main.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"schemion\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"schemion\"] = factory();\n\telse\n\t\troot[\"schemion\"] = factory();\n})(this || global || window, () => {\nreturn ","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[622](0, __webpack_exports__);\n","// replaced at compile time with version from package.json\nclass SchemaError extends Error {\n    constructor (message: string) {\n        super(message);\n        this.name = 'SchemaError';\n    }\n}\n\ninterface Config {\n    shouldValidateSchema?: boolean;\n    strict?: boolean;\n}\n\ntype TypeMap = {\n    string: string;\n    number: number;\n    boolean: boolean;\n    object: object;\n    function: Function;\n    undefined: undefined;\n    any: any\n    symbol: symbol;\n}\n\nconst typeMapKeys = [\n    'string',\n    'number',\n    'boolean',\n    'object',\n    'function',\n    'undefined',\n    'any',\n    'symbol'\n];\n\nexport type Schema = keyof TypeMap\n    | Schema[]\n    | { [key: string]: Schema };\n\nexport type SchemaResult<T> =\n    T extends keyof TypeMap\n        ? TypeMap[T]\n        :\n    T extends Schema[]\n        ? SchemaResult<T[number]>[]\n        :\n    T extends { [ key: string ]: Schema }\n        ? { [K in keyof T]: SchemaResult<T[K]> }\n        :\n    never;\n\nexport function matchesAtomic (o: unknown, schema: keyof TypeMap, _: Config): boolean {\n    if (schema === 'any') {\n        return true;\n    }\n    return typeof o === schema;\n}\n\nexport function matchArray<T extends Schema> (o: unknown, schema: T[], config: Config): o is SchemaResult<T> {\n    return Array.isArray(o)\n        && (o.length === schema.length || !config.strict)\n        && schema.every((s, i) => matches(o[i], s, null, {\n            ...config,\n            shouldValidateSchema: false\n        }));\n}\n\nexport function matchObject<T extends { [k: string]: Schema }, D> (\n    o: unknown,\n    schema: T,\n    defaults: { [P in keyof T]?: SchemaResult<T[P]> } = {},\n    config: Config\n): o is SchemaResult<T> {\n    if (typeof o !== 'object' || o === null) {\n        return false;\n    }\n\n    // clone so can safely mutate (adding defaults)\n    let objClone: Record<string, unknown> = { ...o as Record<string, unknown> };\n    for (const key in defaults) {\n        objClone[key] ??= defaults[key];\n    }\n\n    if (config.strict) {\n        if (Object.keys(objClone).length !== Object.keys(schema).length) {\n            return false;\n        }\n    }\n\n    for (const key in schema) {\n        if (!matches(objClone[key], schema[key], null, {\n            ...config,\n            shouldValidateSchema: false\n        })) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\nexport function validateSchema (schema: unknown): asserts schema is Schema {\n    if (typeof schema === 'string') {\n        if (typeMapKeys.indexOf(schema) < 0) {\n            throw new SchemaError('Invalid schema');\n        }\n\n    } else if (Array.isArray(schema)) {\n        schema.forEach(validateSchema);\n\n    } else if (typeof schema === 'object') {\n        Object.keys(schema)\n            .forEach(k => validateSchema(schema[k as keyof typeof schema]))\n\n    } else {\n        throw new SchemaError('Invalid schema');\n    }\n}\n\nexport function matches<T extends Schema> (\n    o: unknown,\n    schema: T,\n    defaults: T extends object\n        ? { [P in keyof T]?: SchemaResult<T[P]> } | null\n        : null = null,\n    config: Config = {\n        shouldValidateSchema: true,\n        strict: false\n    }\n): o is SchemaResult<T> {\n    if (config.shouldValidateSchema) {\n        validateSchema(schema);\n    }\n\n    if (typeof schema === 'string') {\n        return matchesAtomic(o, schema as keyof TypeMap, config);\n    }\n    if (Array.isArray(schema)) {\n        return matchArray(o, schema, config);\n    }\n    if (typeof schema === 'object') {\n        return matchObject(o, schema, defaults, config);\n    }\n\n    return false;\n}\n\n// replaced at compile time with version from package.json\nexport const VERSION = '0.0.8';\n\nconst schemion = {\n    matches,\n    VERSION\n};\n\nexport default schemion;"],"names":["root","factory","exports","module","define","amd","this","global","window","__webpack_exports__","message","name","Error","typeMapKeys","matchesAtomic","o","schema","_","matchArray","config","Array","isArray","length","strict","every","s","i","matches","shouldValidateSchema","matchObject","defaults","objClone","key","Object","keys","validateSchema","indexOf","SchemaError","forEach","k","VERSION","schemion"],"sourceRoot":""}